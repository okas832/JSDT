#python=3.7

import esprima
from esprima.scanner import RegExp
import json
import os
import re
import pexpect
import requests
import atexit
from random import randrange
from unit_mutator import *


esprima_obj=[esprima.nodes.TemplateElement.Value,RegExp]
esprima_ignore=[esprima.scanner.SourceLocation,esprima.scanner.Position]
def ast_to_json(ast):
    rtn=dict()
    for key,val in ast.items():
        if isinstance(val,esprima.nodes.Node) :
            rtn[key]=ast_to_json(val)
        elif type(val) in esprima_obj:
            rtn[key]=ast_to_json(val.__dict__)
        elif type(val) in esprima_ignore:
            continue
        elif isinstance(val,list):
            rtn[key]=list()
            for ele in val:
                rtn[key].append(ast_to_json(ele))
        elif type(val) in (int,str,bool) or (val is None): 
            if key=='isAsync':
                rtn["async"]=val
            else:
                rtn[key]=val
        elif isinstance(val,re.Pattern) and 'value'==key and 'regex' in ast.keys():
            rtn[key]=dict()
        else:
            print(ast)
            print(key)
            print(val)
            raise Exception

    if "type" in ast.keys() and ast.type=="ArrowFunctionExpression":
        rtn["id"]=None
    return rtn


class code_mutator():
    '''
    mutation unit
    class objects:
        - mutation_op_case: list of possible mutation. For each Experssions, there are many operations possible.
         mutation_op_case cluster each operation groups into smaller operation groups that are possible to commute without syntantic errors.
         For example, ("<<" , ">>" , ">>>") are possible to be mutated to each others, but they cannot mutate to "in" even though they are grouped by "Binary operation".
    '''
    dirpath=os.path.dirname(os.path.abspath(__file__))
    js_server=pexpect.spawn(f"node {dirpath}/js_codegen/codegen_server.js",encoding='utf-8')
    atexit.register(js_server.close)
    js_server.expect("server is running...")
    js_server.expect("\n")
    port_num=int(js_server.before)
    
    
    def __init__(self,program,seg_loc_change=True):
        '''
        program: strings of target program
        seg_loc_change: If it's true, code string will be replaced to code generated by AST of original code.
        While mutating code, mutated code does not preserve blank line and comments. This cause inconsistency of line number number between original code and mutated code.
        seg_loc_chagne is to compensate the abnormality
        instance objects:
            - history: list of (original_op,mutating_op,loc,node class).
              node class is used for rolling back. Do not directly extract information
        '''
        assert isinstance(program,str)
        self.code=program
        self.recycling=0 # number of recyling of node
        self.history=[]
        
        self.node_mutator_list=[
            node_mutator_op_coversion(self.history),
            node_mutator_op_prefix(self.history)
        ]
        self.worn_out_node_mutator_list=[]
        # find mutatable nodes
        def delegate_func(node,metadata):
            for node_mutator in self.node_mutator_list:
                node_mutator.collect_mutable_node(node,metadata)
        
        if seg_loc_change:
            self.parsed=esprima.parseScript(program)
            self.parsed=esprima.parseScript(self.gen_code(),delegate=delegate_func,loc=True)
        else:
            self.parsed=esprima.parseScript(program,delegate=delegate_func,loc=True)
        # elect
        for i in range(len(self.node_mutator_list)-1,-1,-1):
            if not self.node_mutator_list[i].node_list:
                self.node_mutator_list.pop(i)
        if not self.node_mutator_list:
            print("cannot find any mutable node")
            self.__del__()

    
    def gen_code(self):
        res=requests.post(f'http://127.0.0.1:{code_mutator.port_num}/',data=json.dumps(ast_to_json(self.parsed)).replace("\\'","\'"))
        assert res.status_code==200
        return res.text

    def gen_mutant(self):
        '''
        generate mutant code (string) 
        '''
        #select mutation method
        index=randrange(len(self.node_mutator_list))
        target_node_mutator=self.node_mutator_list[index]

        # mutate AST
        target_node_mutator.random_mutate()
        
        # send target_node to worn_out list if all nodes are mutated ones
        if target_node_mutator.recycling>self.recycling:
            self.node_mutator_list.pop(index)
            self.worn_out_node_mutator_list.append(target_node_mutator)
            if not self.node_mutator_list:
                self.recycling+=1
                self.node_mutator_list=self.worn_out_node_mutator_list
                self.worn_out_node_mutator_list=[]
        
        # make mutant code with AST
        return self.gen_code()
    
    def roll_back(self):
        '''
        roll back code from recent mutation
        '''
        before,after,node,_=self.history.pop()
        assert node.operator==before
        node.operator=after

        
        
        


if __name__ == "__main__":
    '''
    exmample code for 
    '''
    dirname=os.path.dirname(os.path.abspath(__file__))+'/examples'
    with open(f"{dirname}/test.js","r") as f:
        program=f.read()
    mut_manager=code_mutator(program)
    ori_program=mut_manager.gen_code()
    for _ in range(100):
        mut_program=mut_manager.gen_mutant()
        print(f"mutation occurs at line {mut_manager.history[-1][2].loc.start.line}, mutation type: {mut_manager.history[-1][-1]}")
    with open(f"{dirname}/test_origin.js","w") as g:
        g.write(ori_program)

    with open(f"{dirname}/test_mut.js","w") as g:
        g.write(mut_program)
    
    